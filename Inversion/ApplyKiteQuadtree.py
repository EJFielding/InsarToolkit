#!/usr/bin/env python3
'''
Apply Kite's quadtree sampling approach (Jonsson, 2002)
'''

### IMPORT MODULES ---
import argparse
import os
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm, colors
from osgeo import gdal
from kite import Scene


### PARSER ---
def createParser():
    parser = argparse.ArgumentParser(description='Apply Kite\'s quadtree sampling approach (Jonsson, 2002)')

    # Required inputs
    parser.add_argument(dest='dataFldr', type=str, help='Folder with ISCE geocoded outputs')

    # Optional data sets
    parser.add_argument('--ifgName', dest='ifgName', type=str, default='filt_topophase_2stage.unw.geo',
        help='IFG name')
    parser.add_argument('--corName', dest='corName', type=str, default='topophase.cor.geo')
    parser.add_argument('-m','--mask', dest='maskFile', type=str, default=None,
        help='Mask file')

    # Optional inputs
    parser.add_argument('-ct','--corThreshold', dest='corThreshold', type=float, default=0.2, help='Correlation threshold')
    parser.add_argument('--mask-value', dest='maskValue', default=0, help='Value of mask map to mask (default 0; 1 for MODIS watermask)')

    parser.add_argument('--wavelen', dest='wavelen', type=float, default=0.0555,
        help='Radar wavelength')

    parser.add_argument('--epsilon', dest='epsilon', type=float, default=0.02,
        help='Variance threshold. Lower this for more tiles.')
    parser.add_argument('--pctNan', dest='nanAllowed', type=float, default=0.5,
        help='Percentage NaN allowed per tile')
    parser.add_argument('--minTileSize', dest='minTile', type=float, default=0.01,
        help='Minimum tile size in degrees')
    parser.add_argument('--maxTileSize', dest='maxTile', type=float, default=0.2,
        help='Maximum tile size in degrees')

    parser.add_argument('-o','--outName', dest='outName', type=str, default=None,
        help='Output name')

    return parser

def cmdParser(iargs = None):
    parser = createParser()
    return parser.parse_args(args = iargs)



### FUNCTIONS ---
## Format outputs
def formatOutputs(outName):
    '''
        Check that output directory exists.
        Formulate quadtree figure output name.
        Formulate quadtree results output name.
    '''
    # Check that output directory exists
    if outName is None:
        figName = None
        saveName = None
    else:
        # Full path of output name
        outName = os.path.abspath(outName)

        # Check that output directory exists
        outPath = os.path.dirname(outName)

        if os.path.exists(outPath):
            print('Exists: {:s}'.format(outPath))
        else:
            os.mkdir(outPath)
            print('Created directory: {:s}'.format(outPath))

        # Figure name
        figBasename = '{}_quadtree_view'.format(outName)
        figName = os.path.join(outPath,figBasename)

        # Data set name
        saveBasename = '{}_kite_scene'.format(outName)
        saveName = os.path.join(outPath,saveBasename)

    return figName, saveName


## Data loading
def loadData(dataFldr,ifgName,corName,maskFile=None):
    '''
        Return the Kite scene from a folder, e.g., Tr43dsc/20200128_20200116.
        Automatically search for the unwrapped ifg, correlation files.
        Files should be 2-stage unwrapped and geocoded.
    '''
    # Formulate IFG name
    # ifgName = os.path.join(dataFldr,ifgName)
    # corName = os.path.join(dataFldr,corName)

    # Load as Kite Scene
    sc = Scene.import_data(ifgName)

    # Load correlation file
    corDS = gdal.Open(corName, gdal.GA_ReadOnly)
    cor = corDS.GetRasterBand(2).ReadAsArray()
    cor = np.flipud(cor)

    # Load mask if specified
    if maskFile:
        mskDS = gdal.Open(maskFile, gdal.GA_ReadOnly)
        msk = mskDS.GetRasterBand(1).ReadAsArray()
        msk = np.flipud(msk)
    else:
        msk = None

    # Report
    print('Loaded scene: {:s}'.format(ifgName))
    print('Loaded cor file {:s}'.format(corName))

    return sc, cor, msk


## Plottting
def plotMap(Fig,ax,data,title=None,units=None,cmap='viridis'):
    '''
        Plot formatted map of data.
    '''
    # Plot data
    cax = ax.imshow(data,origin='lower',
        cmap=cmap)

    # Format plot
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_title(title)
    cbar = Fig.colorbar(cax,ax=ax,orientation='horizontal')
    cbar.ax.set_title(units)

    return Fig, ax

def plotLeaves(Fig,ax,qt,figName=None):
    '''
        Plot leaves generated by Kite quadtree.
    '''
    # Color limits
    llimit = qt.leaf_medians.min()
    ulimit = qt.leaf_medians.max()

    colorMap = cm.ScalarMappable(norm=colors.Normalize(vmin=llimit,vmax=ulimit))

    # Plot leaves
    for rect, leaf in zip(qt.getMPLRectangles(), qt.leaves):
        color = colorMap.to_rgba(leaf.median)
        rect.set_facecolor(color)
        ax.add_artist(rect)

    # Format figure
    ax.set_xlim(0, qt.leaf_eastings.max())
    ax.set_ylim(0, qt.leaf_northings.max())
    ax.set_aspect(1)
    ax.set_title('Quadtree leaves')
    cbar = Fig.colorbar(colorMap,ax=ax,orientation='vertical')
    cbar.ax.set_ylabel('disp (m)')

    # Save figure
    if figName:
        Fig.savefig(figName,dpi=600)
        print('Saved quadtree figure to: {:s}'.format(figName))

    return Fig, ax


## Masking
def maskByCorrelation(sc,cor,corThreshold):
    '''
        Mask sc.displacement data set by threshold value.
    '''
    # Determine mask
    corMask = (cor < corThreshold)

    # Mask displacement data set
    sc.displacement[corMask] = np.nan

    # Report statistics
    print('Masked by correlation value: {:f}'.format(corThreshold))

    maskSize = np.sum(corMask)
    imgShape = sc.displacement.shape
    imgSize = imgShape[0]*imgShape[1]
    maskPct = maskSize/imgSize*100
    print('\tmasking {:d} / {:d} pixels ({:2.0f} pct)'.\
        format(maskSize,imgSize,maskPct))

    return sc

def maskByMask(sc,msk,maskValue):
    '''
        Mask sc.displacement data by mask map/value.
        maskValue should be 1 for MODIS water data sets.
    '''
    # Determine mask
    mskMask = (msk == maskValue)

    # Mask displacement data set
    sc.displacement[mskMask] = np.nan

    # Report statistics
    print('Masked by masking value: {:f}'.format(maskValue))

    maskSize = np.sum(mskMask)
    imgShape = sc.displacement.shape
    imgSize = imgShape[0]*imgShape[1]
    maskPct = maskSize/imgSize*100
    print('\tmasking {:d} / {:d} pixels ({:2.0f} pct)'.\
        format(maskSize,imgSize,maskPct))

    return sc


## Quadtree
def formatQuadtree(qt,epsilon,nanAllowed,minTile,maxTile):
    '''
        Apply parameters to the quadtree sampling results.
    '''
    qt.epsilon = epsilon        # variance threshold
    qt.nan_allowed = nanAllowed # percentage of NaNs allowed per tile
    qt.tile_size_min = minTile  # minimum tile size in degrees
    qt.tile_size_max = maxTile  # maximum tile size in degrees

    # Report
    print('Quadtree resampling')
    print('\tepsilon: {:f}'.format(epsilon))
    print('\tNaN allowed: {:f}'.format(nanAllowed))
    print('\tMin tile: {:f}'.format(minTile))
    print('\tMax tile: {:f}'.format(maxTile))

    print('There are {:d} leaves'.format(qt.nleaves))

    return qt



### MAIN ---
if __name__ == '__main__':
    # Gather inputs
    inps = cmdParser()

    # Check output directory exists
    figName, saveName = formatOutputs(inps.outName)


    ## Load inputs
    # Load data
    sc, cor, msk = loadData(inps.dataFldr,inps.ifgName,inps.corName,inps.maskFile)


    ## Masking
    # Mask by correlation threshold
    sc = maskByCorrelation(sc,cor,inps.corThreshold)

    # Mask by given mask file
    sc = maskByMask(sc,msk,inps.maskValue)


    ## Convert radians to displacement
    sc.displacement *= inps.wavelen/4/np.pi


    ## Plot data
    # To mask or not to mask
    if inps.maskFile:
        ncols = 3
    else:
        ncols = 2

    # Create inputs figure
    DataFig, axes = plt.subplots(ncols = ncols)

    # Plot displacement
    _,axes[0] = plotMap(DataFig,axes[0],sc.displacement,
        title='Unw phase',units='meters',cmap='RdBu_r')

    # Plot correlation
    _,axes[1] = plotMap(DataFig,axes[1],cor,
        title='Correlation',units='corr coef')

    # Plot mask
    if inps.maskFile:
        _,axes[2] = plotMap(DataFig,axes[2],msk,
            title='Water mask',units='mask value')


    ## Quadtree decomposition
    # Initialize quadtree
    qt = sc.quadtree

    # Quadtree parameters
    qt = formatQuadtree(qt,
        inps.epsilon,inps.nanAllowed,
        inps.minTile,inps.maxTile)

    # Plot leaves
    QTfig, axQT = plt.subplots()
    plotLeaves(QTfig, axQT, qt, figName)

    # Save quadtree
    if saveName:
        sc.save(saveName)
        print('Saved quadtree results to: {:s}'.format(saveName))


    plt.show()